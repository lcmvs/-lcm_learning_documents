# 排序算法

[十大经典排序算法（动图演示）](https://www.cnblogs.com/onepixel/p/7674659.html)

十种常见排序算法可以分为两大类：

- **比较类排序**：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。
- **非比较类排序**：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 

![img](../../%E5%85%AC%E5%BC%80%E6%96%87%E6%A1%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/assets/849589-20190306165258970-1789860540.png)

## 算法复杂度

![img](../../%E5%85%AC%E5%BC%80%E6%96%87%E6%A1%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/assets/849589-20180402133438219-1946132192.png)

**相关概念**

- **稳定**：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。
- **不稳定**：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。
- **时间复杂度**：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。
- **空间复杂度：**是指算法在计算机

内执行时所需存储空间的度量，它也是数据规模n的函数。 

## 冒泡排序

```java
public static void sort(int[] array){
    for(int i=0;i<array.length;i++){
        for(int j=0;j<array.length-i-1;j++){
            if(array[j]>array[j+1]){
                int temp=array[j];
                array[j]=array[j+1];
                array[j+1]=temp;
            }
        }
    }
}
```

## 快速排序

```java
public static void quicksort(int n[], int l, int r) {
    if (l < r) {
        // 一趟快排，并返回交换后基数的下标
        int index = patition(n, l, r);
        // 递归排序基数左边的数组
        sort(n, l, index - 1);
        // 递归排序基数右边的数组
        sort(n, index + 1, r);
    }

}

public static int patition(int nums[], int from, int to) {
    // 设数组的第一个数为标兵
    int p = nums[from];
    //左开始位置
    int left = from;
    //右开始位置
    int right = to;
    while (left < right) {
        // 找到右边第一个小于基数的数
        while (nums[right] >= p && left < right) {
            right --;
        }
        // 找到左边第一个大于基数的数
        while (nums[left] <= p && left < right) {
            left++;
        }
        // 交换两个数
        swap(nums, left, right);
    }
    //让标兵站中间
    swap(nums, from, left);
    return left;
}

private static void swap(int n[], int i, int j) {
    int temp = n[i];
    n[i] = n[j];
    n[j] = temp;
}
```

## 简单选择排序



## 归并排序

归并排序需要一个辅助数组存中间数据，所有浪费O(n)的空间。可以分logn次，合并有序数组的时候时间复杂度O(n)。

#### 例题 数组中的逆序对

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007

<details>
<summary>解题思路</summary>
1.每个数与后面的子数列进行比较，O(n^2)。<br>
2.使用归并排序，合并数列时，可以计算逆序对，时间复杂度O(nlgn)，空间复杂度O(n)。
</details>

