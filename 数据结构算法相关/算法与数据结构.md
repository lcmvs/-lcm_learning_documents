# 数据结构算法学习记录



# 数组



# 链表



# 树

## 树的遍历

### 前中后序遍历

#### 重建二叉树

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

<details>
<summary>解题思路</summary>
先序遍历第一个节点必然是根节点，然后通过根节点找到中序遍历相同的值，说明中序遍历的左边为左子树，右边为右子树。<br>
解题时需要注意，边界值判断，数组是否越界等。
</details>

#### 二叉树的下一个节点

给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。

<details>
<summary>解题思路</summary>
根据中序遍历的特点，分析所有可能性<br>
</details>



### 层次遍历



## 二叉排序树

#### 二叉排序树的第k个节点

给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）  中，按结点数值大小顺序第三小结点的值为4。

<details>
<summary>解题思路</summary>
二叉排序树是一颗有序的树，中序遍历有序,左子节点<根节点<右子节点。<br>
解题时需要注意，值传递和引用传递。<br>
</details>



### 红黑树

#### 明明的随机数

​	明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤1000），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作(同一个测试用例里可能会有多组数据，希望大家能正确处理)。 
<details>
<summary>解题思路</summary>
去重+排序，完美符合平衡二叉树，而红黑树算是一种其他的平衡二叉树<br>
</details>
## 堆排序



# 字符串



```java
//全部小写化，用于忽略大小写情况
String str1 = "ABC".toLowerCase();

//java中有合适的字符串进制转换api
//记得去除进制的标记符号
str=str.replace("0x","");
System.out.println(Integer.parseInt(str,16));
```





# 栈和队列



# 排序算法

[十大经典排序算法（动图演示）](https://www.cnblogs.com/onepixel/p/7674659.html)

十种常见排序算法可以分为两大类：

- **比较类排序**：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。
- **非比较类排序**：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 

![img](assets/849589-20190306165258970-1789860540.png)

#### 0.2 算法复杂度

![img](assets/849589-20180402133438219-1946132192.png)

**0.3 相关概念**

- **稳定**：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。
- **不稳定**：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。
- **时间复杂度**：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。
- **空间复杂度：**是指算法在计算机

内执行时所需存储空间的度量，它也是数据规模n的函数。 

## 冒泡排序

```java
public static void sort(int[] array){
    for(int i=0;i<array.length;i++){
        for(int j=0;j<array.length-i-1;j++){
            if(array[j]>array[j+1]){
                int temp=array[j];
                array[j]=array[j+1];
                array[j+1]=temp;
            }
        }
    }
}
```

## 快速排序

```java
public void sort(int[] array,int from,int to) {
    if(from>=to) return;
    int base=array[from];
    int index=from;
    int next=to;
    for(int i=from;i<to;i++){
        if(index<next){
            if(array[next]<base){
                array[index]=array[next];
                int temp=index;
                index=next;
                next=temp+1;
            }else{
                next--;
            }
        }else{
            if(array[next]>base){
                array[index]=array[next];
                int temp=index;
                index=next;
                next=temp-1;
            }else{
                next++;
            }
        }
    }
    array[index]=base;
    sort(array,from,index-1);
    sort(array,index+1,to);
}
```

## 简单选择排序



## 堆排序









