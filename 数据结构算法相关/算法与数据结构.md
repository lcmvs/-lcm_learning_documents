# 数据结构算法学习记录



# 数组和链表

## 数组

### 数组特性

#### 例题 数组中出现次数超过一半的数

数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。
<details>
<summary>解题思路</summary>
暴力解法：<br>
1.直接使用hashmap遍历一次数组，计算每个数重复的次数。浪费空间。<br>
一个数字出现次数超过一半，那么如果数组有序，则必然是中间数值。<br>
1.先排序，找到中位数，计算重复次数。时间复杂度高。<br>
2.优化排序，不需要完全排序，部分快排，找到中位数，然后计算出中位数的数量。<br>
3.总是删除两个不同的数，如果有一个数超过长度一般，剩下的必然是该数。时间空间效率最高。代码实现，记录一个数，并记录他的重复次数，遇到不同的-1，重复+1<br>
</details>



#### 例题 把数组排成最小的数

输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。



#### 例题 和为s的两个数字

输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。
<details>
<summary>解题思路</summary>
前后夹逼法。
</details>



### 二维数组

#### 例题 二维数组中的查找

在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
<details>
<summary>解题思路</summary>
使用堆排序，大根堆，根节点必然是最大值。jdk的优先队列PriorityQueue。
</details>



## 堆排序

#### 例题 最小的k个数

输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。



## 链表

#### 例题 链表中倒数第k个节点

输入一个链表，输出该链表中倒数第k个结点。
<details>
<summary>解题思路</summary>
暴力解法，使用两次遍历。优化解法，使用两个指针，一次遍历。
</details>



#### 例题 复杂链表的复制

输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）
<details>
<summary>解题思路</summary>
1.暴力解法，直接使用HashMap，记录，源节点和复制节点的关系，两次遍历即可完成，但是浪费空间。<br>
2.巧妙解法，在旧链表中创建新链表，不需要浪费额外空间，需要更多遍历，时间会稍微长一点:<br>
1).复制next 如原来是A->B->C 变成A->A'->B->B'->C->C'<br>
2).复制random pCur是原来链表的结点 pCur.next是复制pCur的结点<br>
2).拆分链表<br>
</details>



#### 例题 两个链表的公共结点

输入两个链表，找出它们的第一个公共结点。

<details>
<summary>解题思路</summary>
1.使用hashset的特性，先将一个链表存入set中，再遍历第二条链表，找到第一个公共节点，浪费O(n)的空间。<br>
2.链表的特性，两个链表有公共节点，就代表后面都是相交的，计算两个链表的长度，相减，长链表先跑一段距离，然后两个链表一起跑，并判断是否是同一个节点。
</details>



#### 例题 链表中的环的入口结点

给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。
<details>
<summary>解题思路</summary>
1.使用hashset的特性，先将链表存入set中，找到第一个公共节点，浪费O(n)的空间。<br>
2.链表的特性，使用快慢指针，如果有环慢指针肯定会被快指针追上，而且追上节点肯定在环中，再让这个节点继续跑一圈，计算环的长度，再用两个指针，一个先跑环的长度，另一个才跑，最后相遇在环的入口。
</details>




## 动态规划

#### 例题 连续子数组的最大和

HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)
<details>
<summary>解题思路</summary>
1.使用循环，用一个值记录当前子数组最大值，另一个值记录累加当前值的最大值。<br>
2.使用递归，记录max，递归每次返回累加当前值的最大值。
</details>



## 哈希

#### 例题 第一个只出现一次的字符

在一个字符串(0<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.
<details>
<summary>解题思路</summary>
1.使用LinkedHashMap，key为字符，value为boolean是否重复。而且还记录了插入顺序。<br>
2.使用HashMap，key为字符，value为插入顺序，重复value置-1。
</details>



# 位运算

## 二进制

#### 例题 二进制中1的个数

输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。
```java
public class Solution {
    public int NumberOf1(int n) {
/*
1.String str=Integer.toBinaryString(n);
2.Integer.bitCount(n);
3.遍历每一个位，统计1的个数。
4.优化使用与运算，如1100&1011=1000。
*/         
/*
                int sum=0;
                while(n!=0){
                    ++sum;
                    n=n&(n-1);
                }
                return sum;
*/
/*
‘>>’和‘>>>’:https://zhidao.baidu.com/question/14164447.html
右移运算符和右移补零运算符
*/
        int sum=0;
        while(n!=0){
            sum=sum+(n&1);
            n=n>>>1;
        }
        return sum;
    }
}
```

## 次方

#### 例题 数组的整数次方

给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。

保证base和exponent不同时为0

Math.pow(base,exponent);



## 异或

#### 例题 数组中只出现一次的数

一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。
<details>
<summary>解题思路</summary>
1.使用hashset，遍历存入，如果遇到重复的，remove。<br>
2.异或的特性，a^a=0,a^0=a,整个数组异或，结果为两个唯一数异或结果。这个结果中某个为1的位，必然一个为0，一个为1，所有可以根据这个条件拆分成两个数列，分别异或，得到两个数字，就是结果。    
</details>



# 递归迭代

## 递归

### 回溯

#### 例题 字符串排序

输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。
输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。
<details>
<summary>解题思路</summary>
用递归回溯的方法，更换字符串中字符的顺序。因为字符可能重复，所有更换顺序时需要判断一下字符是否相同，防止出现重复情况。
</details>



## 迭代

#### 例题 斐波那契数列

斐波那契数列（Fibonacci sequence），又称[黄金分割](https://baike.baidu.com/item/黄金分割/115896)数列、因[数学家](https://baike.baidu.com/item/数学家/1210991)列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“[兔子数列](https://baike.baidu.com/item/兔子数列/6849441)”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波那契数列以如下被以[递推](https://baike.baidu.com/item/递推/1740695)的方法定义：*F*(1)=1，*F*(2)=1, *F*(n)=*F*(n - 1)+*F*(n - 2)（*n* ≥ 3，*n* ∈ N*）

<details>
<summary>解题思路</summary>
1.斐波那契数列使用递归非常简单，套公式就行，但是容易发生栈溢出，而且做了很多多余的计算，效率低下。<br>
2.如果使用迭代，记录当前结果和上一个结果，效率会更高<br>
</details>

##### 变种1 跳台阶

一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。

##### 变种2 变态跳台阶

一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。
<details>
<summary>解题思路</summary>
这个其实就是推导出计算公式为2^n-1，可以使用Math.pow()，但是使用位运算1&lt;&lt;n-1,效率更高。
</details>

##### 变种3 矩形覆盖

我们可以用2\*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2\*1的小矩形无重叠地覆盖一个2\*n的大矩形，总共有多少种方法？

# 树

## 树的遍历

### 前中后序遍历

#### 例题 重建二叉树

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

<details>
<summary>解题思路</summary>
先序遍历第一个节点必然是根节点，然后通过根节点找到中序遍历相同的值，说明中序遍历的左边为左子树，右边为右子树。<br>
解题时需要注意，边界值判断，数组是否越界等。
</details>

#### 例题 二叉树的下一个节点

给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。

<details>
<summary>解题思路</summary>
根据中序遍历的特点，分析所有可能性<br>
</details>

#### 例题 二叉树的镜像

操作给定的二叉树，将其变换为源二叉树的镜像。

二叉树的镜像定义：源二叉树 
    	    8
    	   /  \
    	  6   10
    	 / \  / \
    	5  7 9 11
    	镜像二叉树
    	    8
    	   /  \
    	  10   6
    	 / \  / \
    	11 9 7  5

#### 例题 二叉树的深度

输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。
```java
public class Solution {
    public int TreeDepth(TreeNode root) {
        if(root==null) return 0;
        return 1+Math.max(TreeDepth(root.left),TreeDepth(root.right));
    }
}
```


#### 例题 二叉树中和为某一值的路径

输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)

<details>
<summary>解题思路</summary>
利用递归的特性，通过一个遍历，计算出每条路径的长度<br>
</details>



### 层次遍历

#### 例题 从上往下打印二叉树

从上往下打印出二叉树的每个节点，同层节点从左至右打印。

<details>
<summary>解题思路</summary>
利用双端队列的特性，一层层存入队列中，而且双端队列前后增删效率高。<br>
</details>



## 二叉排序树

### 二叉排序树的特性

#### 例题 二叉排序树的第k个节点

给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）  中，按结点数值大小顺序第三小结点的值为4。

<details>
<summary>解题思路</summary>
二叉排序树是一颗有序的树，中序遍历有序,左子节点<根节点<右子节点。<br>
解题时需要注意，值传递和引用传递。<br>
</details>



#### 例题 二叉排序树的后序遍历

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。

<details>
<summary>解题思路</summary>
二叉排序树后序遍历，必然导致最后一个数为两个子树的中间值，然后使用递归。
</details>



#### 例题 二叉搜索树与双向链表

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。
<details>
<summary>解题思路</summary>
二叉排序树的中序遍历有序，记录头节点，记录遍历到的节点，下一次进行交换。
</details>



### 平衡二叉树

#### 例题 判断二叉树是否是平衡二叉树

输入一棵二叉树，判断该二叉树是否是平衡二叉树。

<details>
<summary>解题思路</summary>
中序遍历有序，后序遍历，计算子树的深度，判断是否平衡。
</details>



### 红黑树

#### 例题 明明的随机数

​	明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤1000），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作(同一个测试用例里可能会有多组数据，希望大家能正确处理)。 
<details>
<summary>解题思路</summary>
去重+排序，完美符合平衡二叉树，而红黑树算是一种其他的平衡二叉树<br>
</details>


# 栈和队列

## 队列





## 栈

#### 例题 两个栈来实现队列

用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。



#### 例题 包含min函数的栈

定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。
<details>
<summary>解题思路</summary>
用一个min栈维护最小值。
</details>





# 查找

## 二分查找



#### 例题 旋转数组的最小数字

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。
NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。



#### 例题 数字在有序数组中出现的次数

统计一个数字在排序数组中出现的次数。
<details>
<summary>解题思路</summary>
1.遍历有序数组，时间复杂度O(n)。<br>
2.二分查找，Arrays.binarySearch()，时间复杂度O(lgn)
</details>


# 数学理论相关

## 质数

#### 例题 质数因子

输入描述:
输入一个long型整数
输出描述:
按照从小到大的顺序输出它的所有质数的因子，以空格隔开。最后一个数后面也要有空格。
输入 180
复制 2 2 3 3 5

<details>
<summary>解题思路</summary>
一个数必然是一条唯一质数组相乘得到
</details>


# java api

## 字符串

```java
//全部小写化，用于忽略大小写情况
String str1 = "ABC".toLowerCase();

//java中有合适的字符串进制转换api
//记得去除进制的标记符号
str=str.replace("0x","");
System.out.println(Integer.parseInt(str,16));

//替换空格
str.toString().replace(" ","%20");

//字符串反转
StringBuilder sb = new StringBuilder(str);
sb.reverse();
```

## 数字

### 四舍五入

```java
//Math.ceil(double a)向上舍入，将数值向上舍入为最为接近的整数，返回值是double类型

//Math.floor(double a)向下舍入，将数值向下舍入为最为接近的整数，返回值是double类型

//Math.round(float a)标准舍入，将数值四舍五入为最为接近的整数，返回值是int类型

//Math.round(double a)标准舍入，将数值四舍五入为最为接近的整数，返回值是long类型

//四舍五入保留两位小数 结果：6.26
Math.round(6.2634675 * 100) * 0.01d;
```



### Integer

```java
//int计算二进制1的个数
Integer.bitCount(num);

//int转二进制字符串
Integer.toBinaryString(num);
```



# 贪心算法



#### 例题 分糖果

老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。你需要按照以下要求，帮助老师给这些孩子分发糖果：

每个孩子至少分配到 1 个糖果。
相邻的孩子中，评分高的孩子必须获得更多的糖果。
那么这样下来，老师至少需要准备多少颗糖果呢？

输入: [1,0,2]
输出: 5



#### 题目描述 加油站

环形路上有n个加油站，第i个加油站的汽油量是gas[i].

你有一辆车，车的油箱可以无限装汽油。从加油站i走到下一个加油站（i+1）花费的油量是cost[i]，你从一个加油站出发，刚开始的时候油箱里面没有汽油。

求从哪个加油站出发可以在环形路上走一圈。返回加油站的下标，如果没有答案的话返回-1。

注意：答案保证唯一。

<details>
<summary>解题思路</summary>
1.首先是想到暴力破解的方法，每个加油站试一遍，时间复杂度O(n^2)。<br>
2.接着想到贪心算法，从剩余油量最多的加油站开始，90%通过率，无法ac。<br>
3.使用数学归纳法，a开始，到d失败，那么a-d之间都是一定失败的，所有下一个从e开始，时间复杂度O(n)
</details>


# 动态规划