



<https://github.com/MisterBooo/LeetCodeAnimation>

# 数组

## 二分查找

```java
    /**
     * 二分查找返回数组下标，无返回-1
     * 需要注意边界值，left和right设为数组的起始下标，
     * left<=right 因为相等也是一个数组,依然需要判断
     * @param array
     * @return
     */
    public static int binarySearch(int[] array,int target){
        int left=0,right=array.length-1;
        while(left<=right){
            int mid=(left+right)/2;
            if(array[mid]==target)
                return mid;
            if(array[mid]<target){
                left=mid+1;
            }else{
                right=mid-1;
            }
        }
        return -1;
    }
```



## 双指针

### 283. 移动零

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**示例:**

```
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
```

**说明**:

1. 必须在原数组上操作，不能拷贝额外的数组。
2. 尽量减少操作次数。

### [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

说明：你不能倾斜容器，且 n 的值至少为 2。

![img](assets/question_11.jpg)

 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。

输入：[1,8,6,2,5,4,8,3,7]
输出：49





## 三指针

### [75. 颜色分类](https://leetcode-cn.com/problems/sort-colors/)

难度中等377收藏分享切换为英文关注反馈

给定一个包含红色、白色和蓝色，一共 *n* 个元素的数组，**原地**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

**注意:**
不能使用代码库中的排序函数来解决这道题。

**示例:**

```
输入: [2,0,2,1,1,0]
输出: [0,0,1,1,2,2]
```

**进阶：**

- 一个直观的解决方案是使用计数排序的两趟扫描算法。
  首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。
- 你能想出一个仅使用常数空间的一趟扫描算法吗？



## 滑动窗口

滑动窗口
209
3
438
76