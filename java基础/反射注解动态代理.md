

# 反射

反射不一样，它是在运行时，而非编译时，动态获取类型的信息，比如接口信息、成员信息、方法信息、构造方法信息等，根据这些动态获取到的信息创建对象、访问/修改成员、调用方法等。



## Class类

```java
public final class Class<T> implements java.io.Serializable,
                              GenericDeclaration,
                              Type,
                              AnnotatedElement {}
```



### 获取方法

```java
Object o=new Object();
Class<?> clazz = o.getClass();
Class<?> dateClass = Date.class;
Class<?> hashMapClass = Class.forName("java.util.HashMap");
```

### 获取字段

```java
//返回所有的public字段，包括其父类的，如果没有字段，返回空数组
public Field[] getFields()
//返回本类声明的所有字段，包括非public的，但不包括父类的
public Field[] getDeclaredFields()
//返回本类或父类中指定名称的public字段，找不到抛出异常NoSuchFieldException
public Field getField(String name)
//返回本类中声明的指定名称的字段，找不到抛出异常NoSuchFieldException
public Field getDeclaredField(String name)
```



### 获取方法

```java
//返回所有的public方法，包括其父类的，如果没有方法，返回空数组
public Method[] getMethods()
//返回本类声明的所有方法，包括非public的，但不包括父类的
public Method[] getDeclaredMethods()
//返回本类或父类中指定名称和参数类型的public方法，找不到抛出异常NoSuchMethodException
public Method getMethod(String name, Class<?>... parameterTypes)
//返回本类中声明的指定名称和参数类型的方法，找不到抛出异常NoSuchMethodException
public Method getDeclaredMethod(String name, Class<?>... parameterTypes)
```



### 创建对象和构造方法

```java
public T newInstance() throws InstantiationException, IllegalAccessException
```

它会调用类的默认构造方法(即无参public构造方法)，若无，会抛出异常InstantiationException。**很多利用反射的库和框架都默认假定类有无参public构造方法，所以当类利用这些库和框架时要记住提供一个。**

newInstance只能使用默认构造方法，Class还有一些方法，可以获取所有的构造方法：

```java
//获取所有的public构造方法，返回值可能为长度为0的空数组
public Constructor<?>[] getConstructors()
//获取所有的构造方法，包括非public的
public Constructor<?>[] getDeclaredConstructors()
//获取指定参数类型的public构造方法，没找到抛出异常NoSuchMethodException
public Constructor<T> getConstructor(Class<?>... parameterTypes)
//获取指定参数类型的构造方法，包括非public的，没找到抛出异常NoSuchMethodException
public Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes) 
```



### 类型检查和转换

```java
ArrayList list=new ArrayList();
//true
System.out.println(list instanceof ArrayList);
//true
System.out.println(list instanceof List);
//true
System.out.println(List.class.isInstance(list));
//true
System.out.println(List.class.isAssignableFrom(ArrayList.class));
//false
System.out.println(ArrayList.class.isAssignableFrom(List.class));
```



## Field类

```java
//获取字段的名称
public String getName()
//判断当前程序是否有该字段的访问权限
public boolean isAccessible()
//flag设为true表示忽略Java的访问检查机制，以允许读写非public的字段
public void setAccessible(boolean flag)
//获取指定对象obj中该字段的值
public Object get(Object obj)
//将指定对象obj中该字段的值设为value
public void set(Object obj, Object value)
```

在get/set方法中，对于静态变量，obj被忽略，可以为null，如果字段值为基本类型，get/set会自动在基本类型与对应的包装类型间进行转换，对于private字段，直接调用get/set会抛出非法访问异常IllegalAccessException，应该先调用setAccessible(true)以关闭Java的检查机制。

```java
List<String> obj = Arrays.asList(new String[]{"老马","编程"});
Class<?> cls = obj.getClass();
for(Field f : cls.getDeclaredFields()){
    f.setAccessible(true);
    System.out.println(f.getName()+" - "+f.get(obj));
}
```



## Method类

```java
//获取方法的名称
public String getName()
//flag设为true表示忽略Java的访问检查机制，以允许调用非public的方法
public void setAccessible(boolean flag)
//在指定对象obj上调用Method代表的方法，传递的参数列表为args
public Object invoke(Object obj, Object... args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException
```

对invoke方法，如果Method为静态方法，obj被忽略，可以为null，args可以为null，也可以为一个空的数组，方法调用的返回值被包装为Object返回，如果实际方法调用抛出异常，异常被包装为InvocationTargetException重新抛出，可以通过getCause方法得到原异常。

```java
Class<?> cls = Integer.class;
try {
    Method method = cls.getMethod("parseInt", new Class[]{String.class});
    System.out.println(method.invoke(null, "123"));
} catch (NoSuchMethodException e) {
    e.printStackTrace();
} catch (InvocationTargetException e) {
    e.printStackTrace();
}
```



## Constructor类

```java
//创建对象
public T newInstance(Object ... initargs) throws InstantiationException, 
     IllegalAccessException, IllegalArgumentException, InvocationTargetException

//获取参数的类型信息
public Class<?>[] getParameterTypes()
//构造方法的修饰符，返回值可通过Modifier类进行解读
public int getModifiers()
//构造方法的注解信息
public Annotation[] getDeclaredAnnotations()
public <T extends Annotation> T getAnnotation(Class<T> annotationClass)
//构造方法中参数的注解信息
public Annotation[][] getParameterAnnotations() 
```

比如

```java
Constructor<StringBuilder> contructor= StringBuilder.class
                    .getConstructor(new Class[]{int.class});
StringBuilder sb = contructor.newInstance(100);
```



## 总结

反射虽然是灵活的，但一般情况下，并不是我们优先建议的，主要原因是：

- 反射更容易出现运行时错误，使用显式的类和接口，编译器能帮我们做类型检查，减少错误，但使用反射，类型是运行时才知道的，编译器无能为力
- 反射的性能要低一些，在访问字段、调用方法前，反射先要查找对应的Field/Method，性能要慢一些      

简单的说，如果能用接口实现同样的灵活性，就不要使用反射。

# 注解 

定义注解与定义接口有点类似，都用了interface，不过注解的interface前多了@，另外，它还有两个元注解@Target和@Retention，这两个注解专门用于定义注解本身。

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override {
}
```

## 元注解

### @Target

@Target表示注解的目标，@Override的目标是方法(ElementType.METHOD)，ElementType是一个枚举，其他可选值有：

- TYPE：表示类、接口（包括注解），或者枚举声明
- FIELD：字段，包括枚举常量
- METHOD：方法
- PARAMETER：方法中的参数
- CONSTRUCTOR：构造方法
- LOCAL_VARIABLE：本地变量
- ANNOTATION_TYPE：注解类型
- PACKAGE：包

目标可以有多个，用{}表示，比如@SuppressWarnings的@Target就有多个，定义为：

```java
@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})
@Retention(RetentionPolicy.SOURCE)
public @interface SuppressWarnings {
    String[] value();
}
```

如果没有声明@Target，默认为适用于所有类型。

### @Retention

@Retention表示注解信息保留到什么时候，取值只能有一个，类型为RetentionPolicy，它是一个枚举，有三个取值：

- SOURCE：只在源代码中保留，编译器将代码编译为字节码文件后就会丢掉
- CLASS：保留到字节码文件中，但Java虚拟机将class文件加载到内存时不一定会在内存中保留
- RUNTIME：一直保留到运行时

如果没有声明@Retention，默认为CLASS。

@Override和@SuppressWarnings都是给编译器用的，所以@Retention都是RetentionPolicy.SOURCE。

### @Documented

**@**Documented 注解表明这个注解应该被 javadoc工具记录。默认情况下,javadoc是不包括注解的. 但如果声明注解时指定了 @Documented,则它会被 javadoc 之类的工具处理, 所以注解类型信息也会被包括在生成的文档中，是一个标记注解，没有成员。

## 注解参数

```java
@Test
public class AnnotationTest {

    public static void main(String[] args){
        AnnotationTest test=new AnnotationTest();
        Annotation[] annotations = test.getClass().getAnnotations();
        System.out.println(Arrays.toString(annotations));
        System.out.println(((Test)annotations[0]).key());
    }

}

@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@interface Test{
    String key() default "key";
    String value() default "value";
}
```



## 查看注解

创建了注解，就可以在程序中使用，注解指定的目标，提供需要的参数，但这还是不会影响到程序的运行。要影响程序，我们要先能查看这些信息。我们主要考虑@Retention为RetentionPolicy.RUNTIME的注解，利用反射机制在运行时进行查看和利用这些信息。

Class、Field、Method、Constructor中都有如下方法：

```java
//获取所有的注解
public Annotation[] getAnnotations()
//获取所有本元素上直接声明的注解，忽略inherited来的
public Annotation[] getDeclaredAnnotations()
//获取指定类型的注解，没有返回null
public <A extends Annotation> A getAnnotation(Class<A> annotationClass)
//判断是否有指定类型的注解
public boolean isAnnotationPresent(Class<? extends Annotation> annotationClass)
```



# jdk动态代理



# cglib动态代理