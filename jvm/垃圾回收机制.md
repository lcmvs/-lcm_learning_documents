# 垃圾回收机制



## 对象已死？



### 引用计数法

1.1算法分析　

　　引用计数是垃圾收集器中的早期策略。在这种方法中，堆中每个对象实例都有一个引用计数。当一个对象被创建时，且将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1（a = b,则b引用的对象实例的计数器+1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1。任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1。

1.2优缺点

优点：

　　引用计数收集器可以很快的执行，交织在程序运行中。对程序需要不被长时间打断的实时环境比较有利。

缺点： 

　　无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0.



### 可达性分析算法

　根搜索算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。

java中可作为GC Root的对象有

   1.虚拟机栈中引用的对象（本地变量表）

   2.方法区中静态属性引用的对象

　　3. 方法区中常量引用的对象

   4.本地方法栈中引用的对象（Native对象）



### 引用



#### 强引用

```java
Object o=new Object;
```
这就是强引用，垃圾回收器永远不会回收被强引用引用的对象。
#### 软引用

```java
SoftReference<Object> softReference=new SoftReference<>(object);
```
**在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围进行二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。**

因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。

#### 弱引用


 被弱引用关联的对象只能存活到下一次垃圾回收发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收只被弱引用关联的对象。

okhttp使用弱引用做连接池里面每个连接的引用计数。

```java
//RealConnection.java
public final List<Reference<StreamAllocation>> allocations = new ArrayList<>();

//StreamAllocation.java
public void acquire(RealConnection connection, boolean reportedAcquired) {
    assert (Thread.holdsLock(connectionPool));
    if (this.connection != null) throw new IllegalStateException();

    this.connection = connection;
    this.reportedAcquired = reportedAcquired;
    connection.allocations.add(new StreamAllocationReference(this, callStackTrace));
}

public static final class StreamAllocationReference extends WeakReference<StreamAllocation> {
  /**
   * Captures the stack trace at the time the Call is executed or enqueued. This is helpful for
   * identifying the origin of connection leaks.
   */
  public final Object callStackTrace;

  StreamAllocationReference(StreamAllocation referent, Object callStackTrace) {
    super(referent);
    this.callStackTrace = callStackTrace;
  }
}
```

当StreamAllocation从连接池ConnectionPool获取到一个连接RealConnection时，会向allocations放入一个弱引用，等回收空闲连接时，通过判断allocations这个弱引用list持有的对象数量，等于0代表空闲连接，可以释放。

#### 虚引用

一个对象是都有虚引用的存在都不会对生存时间都构成影响，也无法通过虚引用来获取对一个对象的真实引用。唯一的用处：能在对象被GC时收到系统通知，JAVA中用PhantomReference来实现虚引用。



## 垃圾收集算法



### 复制算法

复制算法是为了解决标记-清除算法的效率问题的，其思想如下：将可用内存的容量分为大小相等的两块，每次只使用其中的一块，当这一块内存使用完了，就把存活着的对象复制到另外一块上面，然后再把已使用过的内存空间清理掉。

优点：每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。
缺点：算法的代价是将内存缩小为了原来的一半，未免太高了一点。

#### 新生代

主要用于回收新生代；IBM研究表明：98%的对象朝生夕死，所有不需要1：1的划分空间。

HotSpot默认eden:survivor=8:1，也就是说新生代只有10%的内存会被浪费。

当然，98%的对象可回收只是一般场景下的数据，无法保证每次只有10%的对象存活，当survivor空间不足时，需要依赖其他内存进行分配担保。

#### 分配担保

如果一块survivor空间没有足够的空间存放新生代的存活对象，这些对象将直接通过分配担保机制进入老年代。


###  标记-清除算法

​      该算法如同它的名字一样，分为两个阶段：标记、清除。首先标记出所有需要回收的对象，然后，统一清除这些被标记的对象。

该算法的缺点是：

1、效率不高；标记和清除两个过程的效率都不高。

2、产生大量不连续的内存碎片，导致有大量内存剩余的情况下，由于，没有连续的空间来存放较大的对象，从而触发了另一次垃圾收集动作。


### 标记-整理算法

从名字可以看出，该算法是对“标记-清除”算法的改进升级版。

同样的该算法分为两个阶段：标记、整理。

标记阶段同“标记-清除”算法。

整理阶段，不是直接对标记对象进行清理，而是让所有存活的对象都移动到一端，然后，直接把边界以外的内存清空。这就解决了“标记-清除”算法会造成大量不连续内存碎片的问题。



### 分代收集算法

 分代收集算法是根据对象的存活周期的不同，将内存划分为几块。当前的商业虚拟机的垃圾收集都采用了该算法。一般把Java堆分成新生代（年轻代）和老年代（年老代）。这样就可以根据各年代中对象的存活周期来选择最合适的收集算法了。

新生代，由于只有少量的对象能存活下来，所以选用“**复制算法**”，只需要付出少量存活对象的复制成本。

老年代，由于对象的存活率高，没有额外的空间分担，就必须使用“**标记-清除**”或“**标记-整理**”算法。



## HotSpot的算法实现



### 枚举根节点

[请教下，识jvm堆栈中一个数据类型是否为为引用类型，目前虚拟机实现中是如何做的？](https://www.iteye.com/blog/rednaxelafx-1044951)

我们知道在可达性分析算法中是需要有GC Roots节点，可作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的局部变量表）中，现在很多应用仅仅方法区就有数百兆，如果要逐个检查这里面的引用，那么必然会消耗很多时间。而且因为在枚举GC Roots节点时，程序时需要停顿的（不可以出现分析过程中对象引用关系还在不断变化的情况，这是保证分析结果准确性的基础。）所以我们不可能花费大量的时间去扫描方法区，那么虚拟机是如何实现在不扫描方法区的情况下找到可作为GC Roots的对象呢？

在HotSpot的实现中，是使用一组称为OopMap的数据结构来达到这个目的的，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样，GC在扫描时就可以直接得知这些信息了。

### 安全点

通过OopMap，HotSpot可以很快完成GC Roots的查找，但是，如果在每一行代码都有可能发生GC，那么也就意味着得为每一行代码的指令都生成OopMap，这样将占用大量的空间。实际上，HotSpot也不会这么做。

HotSpot只在特定的位置记录了OopMap，这些位置就叫做安全点（Safepoint），也就是说，程序并不能在任意地方都可以停下来进行GC，只有到达安全点时才能暂停进行GC。

在安全点中，HotSpot也会开始记录虚拟机的相关信息，如OopMap信息的录入。安全点的选择不能太少，否则GC等待时间太长；也不能太多，否则会增大运行负荷，其选择的原则为“是否具有让程序长时间执行的特征”，如方法调用，循环等等。具体安全点有下面几个：

(1) 循环的末尾 (防止大循环的时候一直不进入Safepoint，而其他线程在等待它进入Safepoint)
(2) 方法返回前
(3) 调用方法的call之后
(4) 抛出异常的位置

而安全点暂停线程运行的手段有两种：抢先式中断和主动式中断。
抢先式中断

不需要线程的执行代码主动配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它跑到安全点上再暂停。不过现在的虚拟机几乎没有采用此算法的。
主动式中断

GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时去主动轮询查询此标志，发现中断标志为真时就中断自己挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。



### 安全区域

安全点的使用似乎解决了OopMap计算的效率的问题，但是这里还有一个问题。安全点需要程序自己跑过去，那么对于那些已经停在路边休息或者看风景的程序（比如那些处在Sleep或者Blocked状态的线程），他们可能并不会在很短的时间内跑到安全点去。所以这里为了解决这个问题，又引入了安全区域的概念。

安全区域很好理解，就是在程序的一段代码片段中并不会导致引用关系发生变化，也就不用去更新OopMap表了，那么在这段代码区域内任何地方进行GC都是没有问题的。这段区域就称之为安全区域。线程执行的过程中，如果进入到安全区域内，就会标志自己已经进行到安全区域了。那么虚拟机要进行GC的时候，发现该线程已经运行到安全区域，就不会管该线程的死活了。所以，该线程在脱离安全区域的时候，要自己检查系统是否已经完成了GC或者根节点枚举（这个跟GC的算法有关系），如果完成了就继续执行，如果未完成，它就必须等待收到可以安全离开安全区域的Safe Region的信号为止。



## 垃圾收集器

![img](assets/3b3c42d2.jpg)

上图展示了7种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器。Hotspot实现了如此多的收集器，正是因为目前并无完美的收集器出现，只是选择对具体应用最适合的收集器。

|        收集器         | 串行、并行or并发 | 新生代/老年代 |        算法        |     目标     |                 适用场景                  |
| :-------------------: | :--------------: | :-----------: | :----------------: | :----------: | :---------------------------------------: |
|      **Serial**       |       串行       |    新生代     |      复制算法      | 响应速度优先 |          单CPU环境下的Client模式          |
|    **Serial Old**     |       串行       |    老年代     |     标记-整理      | 响应速度优先 |  单CPU环境下的Client模式、CMS的后备预案   |
|      **ParNew**       |       并行       |    新生代     |      复制算法      | 响应速度优先 |    多CPU环境时在Server模式下与CMS配合     |
| **Parallel Scavenge** |       并行       |    新生代     |      复制算法      |  吞吐量优先  |     在后台运算而不需要太多交互的任务      |
|   **Parallel Old**    |       并行       |    老年代     |     标记-整理      |  吞吐量优先  |     在后台运算而不需要太多交互的任务      |
|        **CMS**        |       并发       |    老年代     |     标记-清除      | 响应速度优先 | 集中在互联网站或B/S系统服务端上的Java应用 |
|        **G1**         |       并发       |     both      | 标记-整理+复制算法 | 响应速度优先 |        面向服务端应用，将来替换CMS        |

### 相关概念

#### 并行和并发

- **并行（Parallel）**：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。
- **并发（Concurrent）**：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行。而垃圾收集程序运行在另一个CPU上。

### Serial 串行收集器

Serial**(串行)**是最基本、历史最悠久的垃圾收集器，使用复制算法，曾经是JDK1.3之前新生代唯一的垃圾收集器。

Serial是一个**单线程**的收集器，它不仅仅只会使用一个CPU或一条线程去完成垃圾收集工作，并且在进行垃圾收集的同时，必须暂停其他所有的工作线程，**Stop The World(STW)**，直到垃圾收集结束。

Serial垃圾收集器虽然在收集垃圾过程中需要暂停所有其他的工作线程，但是它简单高效，对于限定单个CPU环境来说，没有线程交互的开销，可以获得最高的单线程垃圾收集效率，而且桌面应用一般分配的内存很小，提顿时间短，因此Serial垃圾收集器依然是java虚拟机运行在**Client**模式下默认的**新生代垃圾收集器**。

下图展示了Serial 收集器（老年代采用Serial Old收集器）的运行过程：

![img](assets/6c281cf0.png)



### ParNew 并行收集器

**ParNew**收集器就是Serial收集器的**多线程版本**，它也是一个**新生代收集器**。除了使用多线程进行垃圾收集外，其余行为包括Serial收集器可用的所有控制参数、收集算法（复制算法）、Stop The World、对象分配规则、回收策略等与Serial收集器完全相同，两者共用了相当多的代码。

ParNew收集器的工作过程如下图（老年代采用Serial Old收集器）：

![img](assets/75122b84.png)

ParNew收集器除了使用多线程收集外，其他与Serial收集器相比并无太多创新之处，但它却是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关的重要原因是，**除了Serial收集器外，目前只有它能和CMS收集器（Concurrent Mark Sweep）配合工作**，CMS收集器是JDK 1.5推出的一个具有划时代意义的收集器，具体内容将在稍后进行介绍。

ParNew 收集器在**单CPU的环境**中绝对不会有比Serial收集器有更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百地保证可以超越。在**多CPU环境**下，随着CPU的数量增加，它对于GC时系统资源的有效利用是很有好处的。它默认开启的收集线程数与CPU的数量相同，在CPU非常多的情况下可使用**-XX:ParallerGCThreads**参数设置。



### Parallel Scavenge 并行收集器

**Parallel Scavenge**收集器也是一个**并行**的**多线程新生代**收集器，它也使用**复制算法**。Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标是**达到一个可控制的吞吐量（Throughput）**。

**吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）。**

假设虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。

**停顿时间越短就越适合需要与用户交互的程序**，良好的响应速度能提升用户体验。而**高吞吐量**则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合**在后台运算而不需要太多交互的任务**。

Parallel Scavenge收集器提供了两个参数用于精准控制吞吐量：

-XX:MaxGCPauseMillis：**控制最大垃圾收集停顿时间**，是一个大于0的毫秒数。GC停顿缩小是以牺牲吞吐量和新生代空间来换取的。

-XX:GCTimeRation：**直接设置吞吐量大小**，是一个大于0小于100的整数，也就是程序运行时间占总时间的比率，默认值是99，即垃圾收集运行最大1%（1/(1+99)）的垃圾收集时间。

Parallel Scavenge收集器除了会显而易见地提供可以精确控制吞吐量的参数，还提供了一个参数**-XX:+UseAdaptiveSizePolicy**，这是一个开关参数，打开参数后，就不需要手工指定新生代的大小（-Xmn）、Eden和Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种方式称为**GC自适应的调节策略（GC Ergonomics）**。自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别。

另外值得注意的一点是，Parallel Scavenge收集器无法与CMS收集器配合使用，所以在JDK 1.6推出Parallel Old之前，如果新生代选择Parallel Scavenge收集器，老年代只有Serial Old收集器能与之配合使用。



### Serial Old串行收集器

Serial Old 是 Serial收集器的老年代版本，它同样是一个**单线程收集器**，使用**“标记-整理”（Mark-Compact）**算法。

此收集器的主要意义也是在于给Client模式下的虚拟机使用。如果在Server模式下，它还有两大用途：

- 在JDK1.5 以及之前版本（Parallel Old诞生以前）中与Parallel Scavenge收集器搭配使用。
- 作为CMS收集器的后备预案，在并发收集发生**Concurrent Mode Failure**时使用。



### Parallel Old并行收集器

Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用**多线程**和**“标记-整理”**算法。前面已经提到过，这个收集器是在JDK 1.6中才开始提供的，在此之前，如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old以外别无选择，所以在Parallel Old诞生以后，**“吞吐量优先”收集器**终于有了比较名副其实的应用组合，在**注重吞吐量**以及**CPU资源敏感**的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。Parallel Old收集器的工作流程与Parallel Scavenge相同，这里给出Parallel Scavenge/Parallel Old收集器配合使用的流程图：

![img](assets/b1800d45.png)



### CMS并发收集器

**CMS（Concurrent Mark Sweep）**收集器是一种以**获取最短回收停顿时间**为目标的收集器，它非常符合那些集中在互联网站或者B/S系统的服务端上的Java应用，这些应用都非常重视服务的响应速度。从名字上（“Mark Sweep”）就可以看出它是基于**“标记-清除”**算法实现的。

CMS收集器工作的整个流程分为以下4个步骤：

- **初始标记（CMS initial mark）**：仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，需要“Stop The World”。
- **并发标记（CMS concurrent mark）**：进行**GC Roots Tracing**的过程，在整个过程中耗时最长。
- **重新标记（CMS remark）**：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。此阶段也需要“Stop The World”。
- **并发清除（CMS concurrent sweep）**

由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。通过下图可以比较清楚地看到CMS收集器的运作步骤中并发和需要停顿的时间：

![img](assets/f60599b2.png)

**优点**

CMS是一款优秀的收集器，它的主要**优点**在名字上已经体现出来了：**并发收集**、**低停顿**，因此CMS收集器也被称为**并发低停顿收集器（Concurrent Low Pause Collector）**。

**缺点**

- **对CPU资源非常敏感** 其实，面向并发设计的程序都对CPU资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。**CMS默认启动的回收线程数是（CPU数量+3）/4**，也就是当CPU在4个以上时，并发回收时垃圾收集线程不少于25%的CPU资源，并且随着CPU数量的增加而下降。但是**当CPU不足4个时（比如2个），CMS对用户程序的影响就可能变得很大**，如果本来CPU负载就比较大，还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了50%，其实也让人无法接受。
- **无法处理浮动垃圾（Floating Garbage）** 可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。**由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生。**这一部分垃圾出现在标记过程之后，CMS无法再当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就被称为**“浮动垃圾”**。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，**需要预留一部分空间提供并发收集时的程序运作使用。jdk1.5默认当老年代使用了68%的空间就会被激活，jdk1.6启动阈值提升到92%。**要是预留空间无法满足程序需求，就会出现“Concurrent Mode Failure”失败，虚拟机会临时启动Serial Old收集器来重新进行老年代的垃圾回收，这样导致提顿时间变得很长。
- **标记-清除算法导致的空间碎片** CMS是一款基于“标记-清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不触发一次full gc，**内存整理**无法并发，导致停顿边长，cms收集器提供一个fullgc时开启内存整理 的参数`-XX:+UseCMSCompactAtFullCollection`，默认是开启的，
`-XX:CMSFullGCsBeforeCompaction`设置执行多少次不压缩的fullgc后执行一次压缩，**默认0，每次进入fullgc都执行压缩。**



### G1并发收集器

[G1 垃圾收集器介绍](<https://www.javadoop.com/post/g1>)

[Garbage First G1收集器 理解和原理分析](<https://liuzhengyang.github.io/2017/06/07/garbage-first-collector/>)

[深入理解g1垃圾收集器](http://ifeve.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3g1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/)

- 1、年轻代收集
- 2、并发收集，和应用线程同时执行
- 3、混合式垃圾收集
- 4、必要时的 Full GC

**G1（Garbage-First）**收集器是当今收集器技术发展最前沿的成果之一，它是一款**面向服务端应用**的垃圾收集器，HotSpot开发团队赋予它的使命是（在比较长期的）未来可以替换掉JDK 1.5中发布的CMS收集器。与其他GC收集器相比，G1具备如下特点：

- **并行与并发** G1 能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短“Stop The World”停顿时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。
- **分代收集** 与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同方式去处理新创建的对象和已存活一段时间、熬过多次GC的旧对象来获取更好的收集效果。
- **空间整合** G1从整体来看是基于**“标记-整理”**算法实现的收集器，从局部（两个Region之间）上来看是基于**“复制”**算法实现的。这意味着G1运行期间不会产生内存空间碎片，收集后能提供规整的可用内存。此特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。
- **可预测的停顿** 这是G1相对CMS的一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了降低停顿外，还能**建立可预测的停顿时间模型**，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在GC上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。

**横跨整个堆内存**

在G1之前的其他收集器进行收集的范围都是整个新生代或者老生代，而G1不再是这样。G1在使用时，Java堆的内存布局与其他收集器有很大区别，它**将整个Java堆划分为多个大小相等的独立区域（Region）**，虽然还保留新生代和老年代的概念，但**新生代和老年代不再是物理隔离的了，而都是一部分Region（不需要连续）的集合**。

**建立可预测的时间模型**

G1收集器之所以能建立可预测的停顿时间模型，是因为它可以**有计划地避免在整个Java堆中进行全区域的垃圾收集**。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），**在后台维护一个优先列表**，每次根据允许的收集时间，**优先回收价值最大的Region（这也就是Garbage-First名称的来由）**。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。

**避免全堆扫描——Remembered Set**

G1把Java堆分为多个Region，就是“化整为零”。但是Region不可能是孤立的，一个对象分配在某个Region中，可以与整个Java堆任意的对象发生引用关系。在做可达性分析确定对象是否存活的时候，需要扫描整个Java堆才能保证准确性，这显然是对GC效率的极大伤害。

为了避免全堆扫描的发生，虚拟机**为G1中每个Region维护了一个与之对应的Remembered Set**。虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，便通过CardTable**把相关引用信息记录到被引用对象所属的Region的Remembered Set之中**。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。

#### 年轻代并行gc

![4](../../%E5%85%AC%E5%BC%80%E6%96%87%E6%A1%A3/jvm/assets/2.png)

eden区空间耗尽，会触发young gc，一部分存活对象晋升到老年代，一部分存入存入survivor区，将旧的eden区清空，并调整新的eden区和survivor区大小。



#### 老年代并发gc

- **初始标记（Initial Marking）** 仅仅只是标记一下GC Roots 能直接关联到的对象，并且修改**TAMS（Nest Top Mark Start）**的值，让下一阶段用户程序并发运行时，能在正确可以的Region中创建对象，此阶段需要**停顿线程**，但耗时很短。
- **扫描根分区（Root Region）**找出所有的GC Roots的Region, 然后从这些Region开始标记可到达的对象，是一个并发阶段。这个阶段不允许young gc。
- **并发标记（Concurrent Marking）** 从GC Root 开始对堆中对象进行**可达性分析**，找到存活对象，此阶段耗时较长，但**可与用户程序并发执行**。
- **最终标记（Final Marking）** 为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在**线程的Remembered Set Logs**里面，最终标记阶段需要**把Remembered Set Logs的数据合并到Remembered Set中**，这阶段需要**停顿线程**，但是**可并行执行**。
- **筛选回收（Live Data Counting and Evacuation）** 首先对各个Region中的回收价值和成本进行排序，根据用户所期望的GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。

通过下图可以比较清楚地看到G1收集器的运作步骤中并发和需要停顿的阶段（Safepoint处）：

![img](assets/0bce1667.png)



### 理解GC日志





### 垃圾收集器参数

| **参数**                       | **描述**                                                     |
| ------------------------------ | ------------------------------------------------------------ |
| UseSerialGC                    | 虚拟机运行在Client模式的默认值，打开此开关参数后， 使用**Serial+Serial Old**收集器组合进行垃圾收集。 |
| UseParNewGC                    | 打开此开关参数后，使用**ParNew+Serial Old**收集器组合进 行垃圾收集。 |
| UseConcMarkSweepGC             | 打开此开关参数后，使用**ParNew+CMS+Serial Old**收集器组合进行垃圾收集。Serial Old作为CMS收集器出现Concurrent  Mode Failure的备用垃圾收集器。 |
| UseParallelGC                  | 虚拟机运行在Server模式的默认值，打开此开关参数后， 使用**Parallel Scavenge+Serial Old**收集器组合进行垃圾收集。 |
| UseParallelOldGC               | 打开此开关参数后， 使用**Parallel Scavenge+Parallel Old**收集器组合进行垃圾收集。 |
| SurvivorRation                 | 新生代内存中Eden区域与Survivor区域容量比值，默认是8，即 Eden:Survivor=8:1. |
| PretenureSizeThreshold         | 直接晋升到年老代的对象大小，设置此参数后，超过该大小的 对象直接在年老代中分配内存。 |
| MaxTenuringThreshold           | 直接晋升到年老代的对象年龄，每个对象在一次Minor GC之后还 存活，则年龄加1，当年龄超过该值时进入年老代。 |
| UseAdaptiveSizePolicy          | java虚拟机动态自适应策略，动态调整年老代对象年龄和各个区域大小。 |
| HandlePromotionFailure         | 是否允许担保分配内存失败，即整个年老代空间不足，而整个新生代中Eden和Survivor对象都存活的极端情况。 |
| ParallelGCThreads              | 设置并行GC时进行内存回收的线程数。                           |
| GCTimeRation                   | Parallel Scavenge收集器运行时间占总时间比率。                |
| MaxGCPauseMillis               | Parallel Scavenge收集器最大GC停顿时间。                      |
| CMSInitiatingOccupancyFraction | 设置CMS收集器在年老代空间被使用多少百分比之后触发垃圾收集，默认是68%。 |
| UseCMSCompactAtFullCollection  | 设置CMS收集器在完成垃圾收集之后是否进行一次内存整理。        |
| CMSFullGCsBeforeCompaction     | 设置CMS收集器在进行多少次垃圾收集之后才进行一次内存整理。    |



## 内存回收及分配策略

新生代gc Minor GC

新生代的gc，非常频繁，回收速度也快。

老年代gc Major GC/Full GC

老年代的gc，一般出现Major GC，总是会伴随Minor GC（非绝对），Major GC比Minor GC慢10倍以上。



### 对象优先在Eden区分配





### 大对象直接进入老年代

写程序时应该避免，朝生夕死的大对象，因为大对象会直接进入老年代。



### 长期存活的对象将进入老年代

默认15岁。没经过一次Minor GC，年纪加一，到达一定程度就会进入老年代。



### 动态对象年龄判断

如果survivor空间中相同年龄所有对象大小的总和大于survivor空间的一半，年龄大于等于该年龄的对象直接进入老年代。



### 空间分配担保

Minor GC之前，jvm会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果成立，那么Minor GC确保是安全的。

如果不成立，会查看HandlePromotionFailure，查看是否需要担保失败，如果允许，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小。

如果大于，尝试进行一次Minor GC，尽管是有风险的。

如果小于，或者不允许冒险，则要改为一次full gc。



### 美团GC优化案例

（本文中三个案例使用的垃圾回收器均为ParNew+CMS，CMS失败时Serial Old替补)

[从实际案例聊聊Java应用的GC优化](https://tech.meituan.com/2017/12/29/jvm-optimize.html)

#### 案例一 Major GC和Minor GC频繁

服务情况：Minor GC每分钟100次 ，Major GC每4分钟一次，单次Minor GC耗时25ms，单次Major GC耗时200ms，接口响应时间50ms。

由于这个服务要求低延时高可用，结合上文中提到的GC对服务响应时间的影响，计算可知由于Minor GC的发生，12.5%的请求响应时间会增加，其中8.3%的请求响应时间会增加25ms，可见当前GC情况对响应时间影响较大。

*（50ms+25ms）× 100次/60000ms = 12.5%，50ms × 100次/60000ms = 8.3%* 。

优化目标：降低TP99、TP90时间。

通过扩容新生代为为原来的三倍，单次Minor GC时间增加小于5ms，频率下降了60%，服务响应时间TP90，TP99都下降了10ms+，服务可用性得到提升。

如何选择各分区大小应该依赖应用程序中**对象生命周期的分布情况：如果应用存在大量的短期对象，应该选择较大的年轻代；如果存在相对较多的持久对象，老年代应该适当增大。**



#### 案例二 请求高峰期发生GC，导致服务可用性下降

GC日志显示，高峰期CMS在重标记（Remark）阶段耗时1.39s。Remark阶段是Stop-The-World（以下简称为STW）的，即在执行垃圾回收时，Java应用程序中除了垃圾回收器线程之外其他所有线程都被挂起，意味着在此期间，用户正常工作的线程全部被暂停下来，这是低延时服务不能接受的。本次优化目标是降低Remark时间。

经过增加CMSScavengeBeforeRemark参数，单次执行时间>200ms的GC停顿消失，从监控上观察，GCtime和业务波动保持一致，不再有明显的毛刺。

通过案例分析了解到，由于跨代引用的存在，CMS在Remark阶段必须扫描整个堆，同时为了避免扫描时新生代有很多对象，增加了可中断的预清理阶段用来等待Minor GC的发生。只是该阶段有时间限制，如果超时等不到Minor GC，Remark时新生代仍然有很多对象，我们的调优策略是，通过参数强制Remark前进行一次Minor GC，从而降低Remark阶段的时间。



#### 案例三 发生Stop-The-World的GC

GC日志如下图（在GC日志中，Full GC是用来说明这次垃圾回收的停顿类型，代表STW类型的GC，并不特指老年代GC），根据GC日志可知本次Full GC耗时1.23s。这个在线服务同样要求低时延高可用。本次优化目标是降低单次STW回收停顿时间，提高可用性。